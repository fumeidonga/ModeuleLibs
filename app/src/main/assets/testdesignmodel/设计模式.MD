
[参考](https://www.jianshu.com/p/6e5eda3a51af)

[参考 1](https://www.zhihu.com/question/39972591)

[参考 2](https://www.jianshu.com/p/acf598db6d4d)

[设计模式学习笔记目录 3](https://blog.csdn.net/self_study/article/details/51234377)


Android架构.docx

### 设计模式的分类
1. 创建型 ：创建对象的模式，对类的实例化进行抽象

    这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。
    这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

    特点：
    封装了具体类的信息， 隐藏类的实例化过程

    常见的模式：
    - 工厂模式与抽象工厂模式 （Factory）（Abstract Factory）：不同条件下创建不同实例
    - 单例模式 （Singleton）：保证一个类仅有一个实例
    - 建造者模式 （Builder）：将一个复杂的构建过程与其具表示细节相分离，使得同样的构建过程可以创建不同的表示
    - 原型模式 （Prototype）：通过拷贝原型创建新的对象


2. 结构型 ： 处理类或者对象的组合

    这些设计模式关注类和对象的组合

    结构型里面又可以分成两类
    1. 类结构型 : 采用继承关系来组合接口实现
    2. 对象结构型 ： 组合对象的方式来实现

    常见的模式：
    - 适配器模式 （Adapter）：使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

    - 装饰器模式 （Decorator）：保持接口，增强性能：修饰类继承被修饰对象的抽象父类，依赖被修饰对象的实例（被修饰对象依赖注入），以实现接口扩展

    - 桥接模式 （Bridge）：两个维度独立变化，依赖方式实现抽象与实现分离：需要一个作为桥接的接口/抽象类，多个角度的实现类依赖注入到抽象类，使它们在抽象层建立一个关联关系

    - 外观模式 （Facade）：在客户端和复杂系统之间再加一层，这一次将调用顺序、依赖关系等处理好。即封装底层实现，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的高层接口

    - 代理模式 （Proxy ）：为其他对象提供一种代理以控制对这个对象的访问：增加中间层（代理层），代理类与底层实现类实现共同接口，并创建底层实现类对象（底层实现类对象依赖注入代理类），以便向外界提供功能接口

    - 过滤器模式 （Filter、Criteria）：使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来

    - 组合模式 （Composite）：用户对单个对象和组合对象的使用具有一致性的统一接口

    - 享元模式 （Flyweight）：享元工厂类控制；HashMap实现缓冲池重用现有的同类对象，如果未找到匹配的对象，则创建新对象

3. 行为型：对在不同的对象之间划分责任和算法的抽象化

    这些设计模式特别关注对象之间的通信

    1. 类的行为模式 ： 用继承关系在几个类之间分配行为
    2. 对象的行为模式 ：用对象聚合的方式来分配行为
    
    常见模式：
    
    - 责任链模式（Chain of Responsibility）：拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

    - 观察者模式（Observer）：一对多的依赖关系，在观察目标类里有一个 ArrayList 存放观察者们。当观察目标对象的状态发生改变，所有依赖于它的观察者都将得到通知，使这些观察者能够自动更新（即使用推送方式）

    - 模板模式（Template）：将这些通用算法抽象出来，在一个抽象类中公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行

    - 命令模式（Command）：将"行为请求者"与"行为实现者"解耦：调用者依赖命令，命令依赖接收者，调用者Invoker→命令Command→接收者Receiver

    - 解释器模式（Interpreter）：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子

    - 迭代器模式（Iterator）：集合中含有迭代器：分离了集合对象的遍历行为，抽象出一个迭代器类来负责，无须暴露该对象的内部表示

    - 中介者模式（Mediator）：对象与对象之间存在大量的关联关系，将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散，可以独立地改变它们之间的交互

    - 策略模式（Strategy）：策略对象依赖注入到context对象，context对象根据它的策略改变而改变它的相关行为(可通过调用内部的策略对象实现相应的具体策略行为)

    - 状态模式（State）：状态对象依赖注入到context对象，context对象根据它的状态改变而改变它的相关行为(可通过调用内部的状态对象实现相应的具体行为)


### 1. 设计模式类型 ###
可以有很多种，共有三大类23种，下面列出一些常见的

* 适配器
* 建造者
* 工厂
* 代理
* 单例
* 策略
* 外观
* 装饰
* 链式
* 桥接

支持自定义的方式，比如 retrofit里面数据解析器

### 2. 为什么要用设计模式 ###
设计模式是某类特定问题的代码设计解决方案
是一套代码设计的经验总结，使用设计模式我们可以：
* 提高代码复用率，降低开发成本和周期
* 提高代码可维护性、可拓展性
* 使代码更加优雅
* 让代码更容易被他人理解

### 3. 设计模式的设计原则 ###
https://blog.csdn.net/self_study/article/details/51234377

##### 3.1 单一职责

##### 3.2 开闭

##### 3.3 里氏替换

##### 3.4 依赖倒置

##### 3.5 接口隔离

##### 3.6 合成复用

##### 3.7 最小知识






















































































